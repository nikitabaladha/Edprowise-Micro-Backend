// /Users/nikita/Desktop/EDPROWISE_Nikita_FINAL/Edprowise_Backend/Edprowise-Micro-Backend/Finance-Module/controllers/Inter-Service-Communication/addInReceiptForFees.js

import mongoose from "mongoose";
import Receipt from "../../models/Receipt.js";
import Ledger from "../../models/Ledger.js";

function toTwoDecimals(value) {
  if (value === null || value === undefined || isNaN(value)) return 0;
  return Math.round(Number(value) * 100) / 100;
}

async function generateReceiptVoucherNumber(schoolId, financialYear) {
  // Find the highest existing voucher number
  const lastEntry = await Receipt.findOne(
    {
      schoolId,
      financialYear,
      status: { $in: ["Posted", "Cancelled"] },
      receiptVoucherNumber: { $exists: true, $ne: null },
    },
    { receiptVoucherNumber: 1 },
    { sort: { receiptVoucherNumber: -1 } }
  );

  let nextNumber = 1;

  if (lastEntry && lastEntry.receiptVoucherNumber) {
    const matches = lastEntry.receiptVoucherNumber.match(/\/(\d+)$/);
    if (matches && matches[1]) {
      nextNumber = parseInt(matches[1]) + 1;
    }
  }

  return `RVN/${financialYear}/${nextNumber}`;
}

async function getFeeLedger(schoolId, financialYear, feeType, session) {
  let ledgerName;

  switch (feeType) {
    case "Registration":
      ledgerName = "Registration Fee";
      break;
    case "Admission":
      ledgerName = "Admission Fee";
      break;
    case "TC":
      ledgerName = "Transfer Certificate Fee";
      break;
    default:
      throw new Error(`Unsupported fee type: ${feeType}`);
  }

  const ledger = await Ledger.findOne({
    schoolId,
    financialYear,
    ledgerName: ledgerName,
  }).session(session);

  if (!ledger) {
    throw new Error(`${ledgerName} ledger not found in the system`);
  }

  return ledger;
}

async function getPaymentMethodLedger(
  schoolId,
  financialYear,
  paymentMode,
  session
) {
  let ledgerName;

  switch (paymentMode) {
    case "Cash":
      ledgerName = "Cash Account";
      break;
    case "Online":
      ledgerName = "Online";
      break;
    case "Cheque":
      ledgerName = "Cheque";
      break;
    default:
      throw new Error(`Unsupported payment mode: ${paymentMode}`);
  }

  const ledger = await Ledger.findOne({
    schoolId,
    financialYear,
    ledgerName: ledgerName,
  }).session(session);

  if (!ledger) {
    throw new Error(`${ledgerName} ledger not found in the system`);
  }

  return ledger;
}

async function findOrCreateReceipt(
  schoolId,
  financialYear,
  entryDate,
  paymentMode,
  session
) {
  // Find existing receipt for same date and payment mode
  const existingReceipt = await Receipt.findOne({
    schoolId,
    financialYear,
    entryDate: {
      $gte: new Date(entryDate.setHours(0, 0, 0, 0)),
      $lt: new Date(entryDate.setHours(23, 59, 59, 999)),
    },
    itemDetails: {
      $elemMatch: {
        ledgerId: (
          await getPaymentMethodLedger(
            schoolId,
            financialYear,
            paymentMode,
            session
          )
        )._id.toString(),
      },
    },
    status: "Posted",
  }).session(session);

  if (existingReceipt) {
    return existingReceipt;
  }

  // Create new receipt
  const receiptVoucherNumber = await generateReceiptVoucherNumber(
    schoolId,
    financialYear
  );

  const newReceipt = new Receipt({
    schoolId,
    financialYear,
    receiptVoucherNumber,
    customizeEntry: true,
    entryDate: new Date(entryDate.setHours(0, 0, 0, 0)),
    receiptDate: new Date(entryDate.setHours(0, 0, 0, 0)),
    narration: "Auto-generated from Fees Module",
    itemDetails: [],
    subTotalAmount: 0,
    subTotalOfDebit: 0,
    totalAmount: 0,
    totalDebitAmount: 0,
    status: "Posted",
    approvalStatus: "Pending",
    sourceModule: "Fees",
    isAutoGenerated: true,
  });

  await newReceipt.save({ session });
  return newReceipt;
}

async function updateReceiptWithFeePayment(
  receipt,
  feeLedger,
  paymentMethodLedger,
  finalAmount,
  session
) {
  // Convert to proper date (start of day for comparison)
  const entryDate = new Date(receipt.entryDate.setHours(0, 0, 0, 0));

  // Find existing fee ledger item
  const existingFeeItemIndex = receipt.itemDetails.findIndex(
    (item) => item.ledgerId.toString() === feeLedger._id.toString()
  );

  // Find existing payment method item
  const existingPaymentItemIndex = receipt.itemDetails.findIndex(
    (item) => item.ledgerId.toString() === paymentMethodLedger._id.toString()
  );

  // Update or add fee ledger item
  if (existingFeeItemIndex !== -1) {
    receipt.itemDetails[existingFeeItemIndex].amount = toTwoDecimals(
      receipt.itemDetails[existingFeeItemIndex].amount + finalAmount
    );
  } else {
    receipt.itemDetails.push({
      itemName: "",
      ledgerId: feeLedger._id.toString(),
      amount: toTwoDecimals(finalAmount),
      debitAmount: 0,
    });
  }

  // Update or add payment method ledger item
  if (existingPaymentItemIndex !== -1) {
    receipt.itemDetails[existingPaymentItemIndex].debitAmount = toTwoDecimals(
      receipt.itemDetails[existingPaymentItemIndex].debitAmount + finalAmount
    );
  } else {
    receipt.itemDetails.push({
      itemName: "",
      ledgerId: paymentMethodLedger._id.toString(),
      amount: 0,
      debitAmount: toTwoDecimals(finalAmount),
    });
  }

  // Recalculate totals
  receipt.subTotalAmount = toTwoDecimals(
    receipt.itemDetails.reduce((sum, item) => sum + (item.amount || 0), 0)
  );
  receipt.subTotalOfDebit = toTwoDecimals(
    receipt.itemDetails.reduce((sum, item) => sum + (item.debitAmount || 0), 0)
  );
  receipt.totalAmount = receipt.subTotalAmount;
  receipt.totalDebitAmount = receipt.subTotalOfDebit;

  await receipt.save({ session });
  return receipt;
}

async function addInReceiptForFees(req, res) {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const { schoolId, financialYear } = req.query;
    const paymentData = req.body;

    if (!schoolId) {
      await session.abortTransaction();
      session.endSession();
      return res.status(401).json({
        hasError: true,
        message: "Access denied: You do not have permission.",
      });
    }

    if (!financialYear) {
      await session.abortTransaction();
      session.endSession();
      return res.status(400).json({
        hasError: true,
        message: "Financial Year is required in query.",
      });
    }

    // Validate required payment data
    const {
      paymentId,
      finalAmount,
      paymentDate,
      academicYear,
      paymentMode,
      feeType,
    } = paymentData;

    if (
      !paymentId ||
      !finalAmount ||
      !paymentDate ||
      !paymentMode ||
      !feeType
    ) {
      await session.abortTransaction();
      session.endSession();
      return res.status(400).json({
        hasError: true,
        message:
          "Missing required fields: paymentId, finalAmount, paymentDate, paymentMode, feeType",
      });
    }

    // Skip if payment mode is "null"
    if (paymentMode === "null") {
      await session.commitTransaction();
      session.endSession();
      return res.status(200).json({
        hasError: false,
        message: "Payment mode is 'null', skipping receipt creation.",
      });
    }

    // Get required ledgers
    const feeLedger = await getFeeLedger(
      schoolId,
      financialYear,
      feeType,
      session
    );
    const paymentMethodLedger = await getPaymentMethodLedger(
      schoolId,
      financialYear,
      paymentMode,
      session
    );

    // Find or create receipt for this date and payment mode
    const receipt = await findOrCreateReceipt(
      schoolId,
      financialYear,
      new Date(paymentDate),
      paymentMode,
      session
    );

    // Update receipt with the new payment
    const updatedReceipt = await updateReceiptWithFeePayment(
      receipt,
      feeLedger,
      paymentMethodLedger,
      finalAmount,
      session
    );

    await session.commitTransaction();
    session.endSession();

    return res.status(200).json({
      hasError: false,
      message: "Payment successfully added to receipt.",
      data: {
        receiptId: updatedReceipt._id,
        receiptVoucherNumber: updatedReceipt.receiptVoucherNumber,
        totalAmount: updatedReceipt.totalAmount,
        itemDetails: updatedReceipt.itemDetails,
      },
    });
  } catch (error) {
    await session.abortTransaction();
    session.endSession();

    console.error("Error adding payment to receipt:", error);
    return res.status(500).json({
      hasError: true,
      message: "Internal server error.",
      error: error.message,
    });
  }
}

export default addInReceiptForFees;
